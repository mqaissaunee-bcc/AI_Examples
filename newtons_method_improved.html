<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Newton's Method for Systems - Enhanced</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        
        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            margin: 0;
            font-size: 2.5em;
            font-weight: 300;
        }
        
        .header p {
            margin: 10px 0 0 0;
            opacity: 0.9;
        }
        
        .nav-tabs {
            display: flex;
            background: #f8f9fa;
            flex-wrap: wrap;
        }
        
        .nav-tab {
            flex: 1;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            background: #f8f9fa;
            border: none;
            font-size: 1em;
            font-weight: 600;
            color: #666;
            transition: all 0.3s ease;
            min-width: 150px;
        }
        
        .nav-tab.active {
            background: #4facfe;
            color: white;
        }
        
        .nav-tab:hover {
            background: #e8f4fd;
            color: #4facfe;
        }
        
        .tab-content {
            display: none;
            padding: 30px;
        }
        
        .tab-content.active {
            display: block;
        }
        
        /* Theory styles */
        .theory-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .concept-card {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 25px;
            border-left: 5px solid #4facfe;
        }
        
        .concept-card h3 {
            margin: 0 0 15px 0;
            color: #2c3e50;
        }
        
        .formula-box {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin: 15px 0;
            text-align: center;
            font-family: 'Courier New', monospace;
            font-size: 1.1em;
            border: 1px solid #e0e0e0;
        }
        
        .algorithm-steps {
            background: #e8f4fd;
            border-radius: 10px;
            padding: 25px;
            margin: 20px 0;
        }
        
        .step {
            display: flex;
            margin-bottom: 20px;
            padding: 15px;
            background: white;
            border-radius: 8px;
        }
        
        .step-number {
            background: #4facfe;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 15px;
            flex-shrink: 0;
        }
        
        .step-title {
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 5px;
        }
        
        /* Simulation styles */
        .main-content {
            display: grid;
            grid-template-columns: 1fr 380px;
            gap: 30px;
        }
        
        .visualization-panel {
            display: flex;
            flex-direction: column;
        }
        
        .canvas-container {
            position: relative;
            background: white;
            border-radius: 10px;
            padding: 10px;
            margin-bottom: 20px;
        }
        
        canvas {
            border: 2px solid #ddd;
            border-radius: 10px;
            background: white;
            width: 100%;
            height: auto;
            cursor: grab;
        }
        
        canvas:active {
            cursor: grabbing;
        }
        
        .canvas-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .canvas-controls button {
            display: block;
            width: 100%;
            margin: 5px 0;
            padding: 8px;
            font-size: 0.9em;
        }
        
        .math-display {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-top: 15px;
        }
        
        .math-display h4 {
            color: #2c3e50;
            margin-bottom: 15px;
        }
        
        .controls {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .control-group {
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid #ddd;
        }
        
        .control-group:last-child {
            border-bottom: none;
        }
        
        .control-group h4 {
            margin: 0 0 15px 0;
            color: #2c3e50;
        }
        
        .system-btn {
            display: block;
            width: 100%;
            padding: 12px;
            margin: 8px 0;
            border: 2px solid #ddd;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            text-align: left;
            transition: all 0.3s ease;
            font-size: 0.95em;
        }
        
        .system-btn.active {
            background: #4facfe;
            color: white;
            border-color: #4facfe;
        }
        
        .system-btn:hover {
            border-color: #4facfe;
            transform: translateX(2px);
        }
        
        .input-group {
            margin: 10px 0;
        }
        
        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            font-size: 0.95em;
        }
        
        .input-group input, .input-group select, .input-group textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-family: inherit;
        }
        
        .input-group textarea {
            font-family: 'Courier New', monospace;
            resize: vertical;
            min-height: 60px;
        }
        
        button {
            padding: 12px 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            margin: 5px 0;
            transition: all 0.3s ease;
            font-size: 0.95em;
        }
        
        .btn-primary {
            background: #4facfe;
            color: white;
        }
        
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        
        .btn-success {
            background: #28a745;
            color: white;
        }
        
        .btn-danger {
            background: #dc3545;
            color: white;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .info-panel {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            border-left: 4px solid #4facfe;
        }
        
        .info-panel h4 {
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .info-panel p {
            margin: 5px 0;
            font-size: 0.95em;
        }
        
        .status-message {
            background: #e8f4fd;
            padding: 12px;
            border-radius: 5px;
            margin: 10px 0;
            font-size: 0.9em;
            border-left: 4px solid #4facfe;
        }
        
        .status-message.success {
            background: #d4edda;
            border-color: #28a745;
            color: #155724;
        }
        
        .status-message.error {
            background: #f8d7da;
            border-color: #dc3545;
            color: #721c24;
        }
        
        .status-message.warning {
            background: #fff3cd;
            border-color: #ffc107;
            color: #856404;
        }
        
        /* Code styles */
        .code-container {
            background: #2d3748;
            color: #e2e8f0;
            border-radius: 10px;
            padding: 25px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.6;
            overflow-x: auto;
        }
        
        .code-examples {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .example-box {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            border-left: 4px solid #4facfe;
        }
        
        .convergence-chart {
            background: white;
            padding: 20px;
            border-radius: 10px;
            margin-top: 15px;
            border: 1px solid #ddd;
        }
        
        .chart-canvas {
            width: 100%;
            height: 200px;
        }
        
        .comparison-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }
        
        .comparison-item {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #ddd;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .comparison-item:hover {
            border-color: #4facfe;
            transform: scale(1.02);
        }
        
        .comparison-item.active {
            border-color: #4facfe;
            background: #e8f4fd;
        }
        
        .tooltip {
            position: relative;
            display: inline-block;
            cursor: help;
            border-bottom: 1px dotted #666;
        }
        
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 250px;
            background-color: #2c3e50;
            color: #fff;
            text-align: left;
            border-radius: 6px;
            padding: 10px;
            position: absolute;
            z-index: 1000;
            bottom: 125%;
            left: 50%;
            margin-left: -125px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.9em;
            line-height: 1.4;
        }
        
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        
        .keyboard-shortcuts {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }
        
        .keyboard-shortcuts h4 {
            margin-bottom: 10px;
        }
        
        .shortcut-item {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            font-size: 0.9em;
        }
        
        .key {
            background: #2c3e50;
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-family: monospace;
            font-weight: bold;
        }
        
        @media (max-width: 1200px) {
            .main-content, .theory-grid, .code-examples {
                grid-template-columns: 1fr;
            }
            
            .controls {
                max-height: none;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎯 Newton's Method for Nonlinear Systems - Enhanced</h1>
            <p>Interactive learning tool with advanced visualizations and analysis</p>
        </div>
        
        <div class="nav-tabs">
            <button class="nav-tab active" data-tab="theory">📚 Theory</button>
            <button class="nav-tab" data-tab="simulation">🎯 Interactive Simulation</button>
            <button class="nav-tab" data-tab="comparison">📊 Comparison Mode</button>
            <button class="nav-tab" data-tab="custom">✏️ Custom System</button>
            <button class="nav-tab" data-tab="code">💻 MATLAB Code</button>
        </div>
        
        <!-- THEORY TAB -->
        <div id="theory" class="tab-content active">
            <h2>🎯 Newton's Method for Nonlinear Systems</h2>
            
            <div class="theory-grid">
                <div class="concept-card">
                    <h3>What is Newton's Method for Systems?</h3>
                    <p>Newton's method extends from finding roots of single equations f(x) = 0 to solving systems of nonlinear equations:</p>
                    <div class="formula-box">
                        f₁(x₁, x₂, ..., xₙ) = 0<br>
                        f₂(x₁, x₂, ..., xₙ) = 0<br>
                        ⋮<br>
                        fₙ(x₁, x₂, ..., xₙ) = 0
                    </div>
                    <p>Instead of using the derivative, we use the <span class="tooltip"><strong>Jacobian matrix</strong><span class="tooltiptext">The Jacobian is a matrix containing all first-order partial derivatives. It generalizes the concept of derivative to multiple dimensions.</span></span> containing all partial derivatives.</p>
                </div>
                
                <div class="concept-card">
                    <h3>🧮 The Jacobian Matrix</h3>
                    <p>The Jacobian J is a matrix of first-order partial derivatives. For a 2×2 system:</p>
                    <div class="formula-box">
                        J = [∂f₁/∂x  ∂f₁/∂y]<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;[∂f₂/∂x  ∂f₂/∂y]
                    </div>
                    <p>This matrix tells us how each function changes with respect to each variable! It's the <span class="tooltip">linear approximation<span class="tooltiptext">The Jacobian provides the best linear approximation to the nonlinear system at a given point.</span></span> of the system.</p>
                </div>
            </div>
            
            <div class="algorithm-steps">
                <h3>🔄 Newton's Method Algorithm</h3>
                
                <div class="step">
                    <div class="step-number">1</div>
                    <div>
                        <div class="step-title">Choose Initial Guess</div>
                        Pick a starting point <strong>x⁰ = (x₀, y₀)</strong> hopefully close to the solution. Poor initial guesses may lead to divergence!
                    </div>
                </div>
                
                <div class="step">
                    <div class="step-number">2</div>
                    <div>
                        <div class="step-title">Evaluate Functions</div>
                        Calculate <strong>F(xᵏ) = [f₁(xᵏ), f₂(xᵏ)]ᵀ</strong> - the vector of function values.
                    </div>
                </div>
                
                <div class="step">
                    <div class="step-number">3</div>
                    <div>
                        <div class="step-title">Compute Jacobian</div>
                        Calculate the Jacobian matrix <strong>J(xᵏ)</strong> at the current point. Check that it's not singular!
                    </div>
                </div>
                
                <div class="step">
                    <div class="step-number">4</div>
                    <div>
                        <div class="step-title">Solve Linear System</div>
                        Solve <strong>J(xᵏ) Δx = -F(xᵏ)</strong> for the step Δx. This is equivalent to inverting the Jacobian.
                    </div>
                </div>
                
                <div class="step">
                    <div class="step-number">5</div>
                    <div>
                        <div class="step-title">Update Solution</div>
                        Update: <strong>xᵏ⁺¹ = xᵏ + Δx</strong>
                    </div>
                </div>
                
                <div class="step">
                    <div class="step-number">6</div>
                    <div>
                        <div class="step-title">Check Convergence</div>
                        If <strong>||F(xᵏ⁺¹)|| < tolerance</strong>, stop. Otherwise, return to step 2. Also check for divergence!
                    </div>
                </div>
            </div>
            
            <div class="concept-card">
                <h3>📊 Example: Circle and Line Intersection</h3>
                <p>Find where a unit circle intersects the line x = y:</p>
                <div class="formula-box">
                    f₁(x,y) = x² + y² - 1 = 0<br>
                    f₂(x,y) = x - y = 0
                </div>
                <p><strong>Jacobian Matrix:</strong></p>
                <div class="formula-box">
                    J(x,y) = [2x   2y]<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1   -1]
                </div>
                <p><strong>Analytical Solution:</strong> (√2/2, √2/2) ≈ (0.707, 0.707)</p>
            </div>
            
            <div class="concept-card">
                <h3>⚡ Convergence Properties</h3>
                <p><strong>Quadratic Convergence:</strong> When Newton's method works, it converges very fast! The error roughly squares at each iteration:</p>
                <div class="formula-box">
                    ||eᵏ⁺¹|| ≈ C ||eᵏ||²
                </div>
                <p>This means the number of correct digits approximately doubles each iteration!</p>
                <p><strong>Requirements for Convergence:</strong></p>
                <ul style="margin-left: 20px; margin-top: 10px;">
                    <li>Initial guess must be sufficiently close to solution</li>
                    <li>Jacobian must be non-singular near the solution</li>
                    <li>Functions must be sufficiently smooth</li>
                </ul>
            </div>
            
            <div class="keyboard-shortcuts">
                <h4>⌨️ Keyboard Shortcuts (in Simulation tab)</h4>
                <div class="shortcut-item">
                    <span>Next Step</span>
                    <span class="key">N</span> or <span class="key">Space</span>
                </div>
                <div class="shortcut-item">
                    <span>Reset</span>
                    <span class="key">R</span>
                </div>
                <div class="shortcut-item">
                    <span>Auto Solve</span>
                    <span class="key">A</span>
                </div>
                <div class="shortcut-item">
                    <span>Export Data</span>
                    <span class="key">E</span>
                </div>
                <div class="shortcut-item">
                    <span>Toggle Math Display</span>
                    <span class="key">M</span>
                </div>
            </div>
        </div>
        
        <!-- SIMULATION TAB -->
        <div id="simulation" class="tab-content">
            <div class="main-content">
                <div class="visualization-panel">
                    <div class="canvas-container">
                        <canvas id="canvas" width="800" height="600"></canvas>
                        <div class="canvas-controls">
                            <button class="btn-secondary" id="resetZoomBtn">Reset View</button>
                            <button class="btn-secondary" id="toggleContoursBtn">Toggle Contours</button>
                            <button class="btn-secondary" id="toggleTangentBtn">Show Tangent</button>
                        </div>
                    </div>
                    
                    <div class="math-display" id="mathDisplay">
                        <h4>📐 Step-by-Step Mathematics</h4>
                        <p style="color: #666;">Take a step to see the mathematics...</p>
                    </div>
                    
                    <div class="convergence-chart">
                        <h4>📈 Convergence Analysis</h4>
                        <canvas id="convergenceChart" class="chart-canvas"></canvas>
                        <div id="convergenceInfo" style="margin-top: 10px; font-size: 0.9em;">
                            <p><strong>Convergence Rate:</strong> <span id="convRate">--</span></p>
                            <p><strong>Expected (Quadratic):</strong> ~2.0</p>
                        </div>
                    </div>
                </div>
                
                <div class="controls">
                    <div class="control-group">
                        <h4>🎲 System of Equations</h4>
                        <div class="system-btn active" data-system="simple">
                            <strong>Simple System</strong><br>
                            <small>f₁: x² + y² - 1 = 0</small><br>
                            <small>f₂: x - y = 0</small>
                        </div>
                        <div class="system-btn" data-system="circle_line">
                            <strong>Circle & Line</strong><br>
                            <small>f₁: x² + y² - 1 = 0</small><br>
                            <small>f₂: x + y - 1 = 0</small>
                        </div>
                        <div class="system-btn" data-system="nonlinear">
                            <strong>Complex Nonlinear</strong><br>
                            <small>f₁: (x-y)² - 1 = 0</small><br>
                            <small>f₂: eˣ - y - 2 = 0</small>
                        </div>
                        <div class="system-btn" data-system="ellipse_hyperbola">
                            <strong>Ellipse & Hyperbola</strong><br>
                            <small>f₁: x²/4 + y² - 1 = 0</small><br>
                            <small>f₂: xy - 1 = 0</small>
                        </div>
                        <div class="system-btn" data-system="custom" id="customSystemBtn" style="display: none;">
                            <strong>Custom System</strong><br>
                            <small id="customEq1">Custom equations</small><br>
                            <small id="customEq2"></small>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <h4>📍 Starting Point</h4>
                        <div class="input-group">
                            <label>x₀:</label>
                            <input type="number" id="startX" value="1.5" step="0.1">
                        </div>
                        <div class="input-group">
                            <label>y₀:</label>
                            <input type="number" id="startY" value="0.5" step="0.1">
                        </div>
                        <div class="input-group">
                            <label>
                                <input type="checkbox" id="useNumericalJacobian"> 
                                Use Numerical Jacobian
                                <span class="tooltip">ℹ️
                                    <span class="tooltiptext">Compare numerical differentiation with analytical Jacobian. Useful for education and debugging.</span>
                                </span>
                            </label>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <button id="stepBtn" class="btn-primary" style="width: 100%;">▶️ Next Step (N)</button>
                        <button id="resetBtn" class="btn-secondary" style="width: 100%;">🔄 Reset (R)</button>
                        <button id="animateBtn" class="btn-primary" style="width: 100%;">⚡ Auto Solve (A)</button>
                        <button id="exportBtn" class="btn-success" style="width: 100%;">💾 Export Data (E)</button>
                    </div>
                    
                    <div class="info-panel">
                        <h4>📊 Current State</h4>
                        <p><strong>Iteration:</strong> <span id="iteration">0</span></p>
                        <p><strong>Point:</strong> (<span id="currentX">1.500</span>, <span id="currentY">0.500</span>)</p>
                        <p><strong>||F(x)||:</strong> <span id="error">--</span></p>
                        <p><strong>f₁(x,y):</strong> <span id="f1">--</span></p>
                        <p><strong>f₂(x,y):</strong> <span id="f2">--</span></p>
                        <p><strong>||Δx||:</strong> <span id="stepSize">--</span></p>
                    </div>
                    
                    <div class="status-message" id="statusMessage">
                        Ready! Select a system and starting point, then click Next Step.
                    </div>
                </div>
            </div>
        </div>
        
        <!-- COMPARISON TAB -->
        <div id="comparison" class="tab-content">
            <h2>📊 Comparison Mode</h2>
            <p style="margin-bottom: 20px;">Compare convergence from different starting points simultaneously.</p>
            
            <div class="comparison-grid" id="startingPointsGrid">
                <div class="comparison-item active" data-start="1.5,0.5">
                    <strong>Point 1</strong><br>
                    (1.5, 0.5)
                </div>
                <div class="comparison-item" data-start="-0.5,1.5">
                    <strong>Point 2</strong><br>
                    (-0.5, 1.5)
                </div>
                <div class="comparison-item" data-start="0.5,0.5">
                    <strong>Point 3</strong><br>
                    (0.5, 0.5)
                </div>
                <div class="comparison-item" data-start="1.0,0.2">
                    <strong>Point 4</strong><br>
                    (1.0, 0.2)
                </div>
            </div>
            
            <div style="margin: 20px 0;">
                <button id="runComparisonBtn" class="btn-primary">🚀 Run Comparison</button>
                <button id="clearComparisonBtn" class="btn-secondary">🗑️ Clear Results</button>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px;">
                <div>
                    <h3>Convergence Paths</h3>
                    <canvas id="comparisonCanvas" width="500" height="500" style="border: 2px solid #ddd; border-radius: 10px; width: 100%;"></canvas>
                </div>
                <div>
                    <h3>Convergence Rates</h3>
                    <canvas id="comparisonChart" width="500" height="500" style="border: 2px solid #ddd; border-radius: 10px; width: 100%;"></canvas>
                    <div id="comparisonResults" style="margin-top: 20px;"></div>
                </div>
            </div>
        </div>
        
        <!-- CUSTOM SYSTEM TAB -->
        <div id="custom" class="tab-content">
            <h2>✏️ Define Custom System</h2>
            <p style="margin-bottom: 20px;">Enter your own system of equations. Use JavaScript syntax: x, y, Math.sin(), Math.exp(), etc.</p>
            
            <div class="concept-card">
                <h3>Function Definitions</h3>
                <div class="input-group">
                    <label>f₁(x, y) =</label>
                    <textarea id="customF1" placeholder="Example: x*x + y*y - 1">x*x + y*y - 1</textarea>
                </div>
                
                <div class="input-group">
                    <label>f₂(x, y) =</label>
                    <textarea id="customF2" placeholder="Example: x - y">x - y</textarea>
                </div>
                
                <h3 style="margin-top: 25px;">Jacobian (Optional)</h3>
                <p style="margin-bottom: 15px; color: #666; font-size: 0.95em;">
                    <strong>Note:</strong> If you leave these fields empty, the system will automatically use numerical differentiation to compute the Jacobian. 
                    Providing analytical derivatives is more accurate and faster, but numerical works well too!
                </p>
                <div class="input-group">
                    <label>∂f₁/∂x =</label>
                    <textarea id="customDf1dx" placeholder="Leave empty for numerical">2*x</textarea>
                </div>
                
                <div class="input-group">
                    <label>∂f₁/∂y =</label>
                    <textarea id="customDf1dy" placeholder="Leave empty for numerical">2*y</textarea>
                </div>
                
                <div class="input-group">
                    <label>∂f₂/∂x =</label>
                    <textarea id="customDf2dx" placeholder="Leave empty for numerical">1</textarea>
                </div>
                
                <div class="input-group">
                    <label>∂f₂/∂y =</label>
                    <textarea id="customDf2dy" placeholder="Leave empty for numerical">-1</textarea>
                </div>
                
                <button id="testCustomBtn" class="btn-secondary" style="margin-top: 15px;">🧪 Test Functions</button>
                <button id="applyCustomBtn" class="btn-primary" style="margin-top: 15px;">✅ Apply & Go to Simulation</button>
                
                <div id="customTestResult" style="margin-top: 15px;"></div>
            </div>
            
            <div class="concept-card" style="margin-top: 20px;">
                <h3>📝 Examples</h3>
                <p><strong>Circle and Line:</strong></p>
                <div class="formula-box" style="text-align: left; font-family: 'Courier New', monospace;">
                    f₁: x*x + y*y - 1<br>
                    f₂: x - y
                </div>
                
                <p style="margin-top: 15px;"><strong>Transcendental:</strong></p>
                <div class="formula-box" style="text-align: left; font-family: 'Courier New', monospace;">
                    f₁: Math.sin(x) - y<br>
                    f₂: Math.cos(y) - x
                </div>
                
                <p style="margin-top: 15px;"><strong>Available Math Functions:</strong></p>
                <p style="font-size: 0.9em;">Math.sin(), Math.cos(), Math.tan(), Math.exp(), Math.log(), Math.sqrt(), Math.pow(base, exp), Math.abs()</p>
            </div>
        </div>
        
        <!-- CODE TAB -->
        <div id="code" class="tab-content">
            <h2>💻 MATLAB Implementation</h2>
            
            <div class="example-box">
                <h3>Complete Newton's Method Function</h3>
                <p>This production-ready MATLAB code implements Newton's method for nonlinear systems with robust error handling.</p>
            </div>
            
            <div class="code-container">
<pre>function [x, history] = newton_system(fun, jac, x0, options)
% NEWTON_SYSTEM - Solve nonlinear system using Newton's method
%
% Inputs:
%   fun     - Function handle returning [f1; f2; ...] 
%   jac     - Function handle returning Jacobian matrix
%   x0      - Initial guess [x0; y0; ...]
%   options - Structure with fields: tol, maxiter, verbose

%% Default parameters
if nargin < 4, options = struct(); end

tol = getfield_safe(options, 'tol', 1e-8);
maxiter = getfield_safe(options, 'maxiter', 50);
verbose = getfield_safe(options, 'verbose', true);

%% Initialize
x = x0(:);
n = length(x);
history.x = zeros(n, maxiter+1);
history.norm_f = zeros(1, maxiter+1);
history.step_size = zeros(1, maxiter);

if verbose
    fprintf('Newton Method for Nonlinear Systems\n');
    fprintf('=====================================\n');
    fprintf('Iter\t||F(x)||\t\tStep Size\tCondition\n');
end

%% Main Newton iteration loop
for k = 1:maxiter
    % Evaluate function and Jacobian
    F = feval(fun, x);
    J = feval(jac, x);
    
    % Store history
    history.x(:, k) = x;
    norm_f = norm(F);
    history.norm_f(k) = norm_f;
    
    % Check convergence
    if norm_f < tol
        if verbose
            fprintf('%d\t%.6e\t\tCONVERGED\n', k-1, norm_f);
        end
        history.iterations = k-1;
        history.x = history.x(:, 1:k);
        history.norm_f = history.norm_f(1:k);
        history.step_size = history.step_size(1:k-1);
        return;
    end
    
    % Check for singular Jacobian
    cond_J = cond(J);
    if cond_J > 1e12
        warning('Jacobian is nearly singular (cond = %.2e)', cond_J);
        break;
    end
    
    % Newton step: solve J * delta = -F
    delta = -J \ F;
    step_size = norm(delta);
    history.step_size(k) = step_size;
    
    % Check for divergence
    if norm(x + delta) > 1e10
        warning('Solution diverging - step leads to ||x|| > 1e10');
        break;
    end
    
    % Update solution
    x = x + delta;
    
    if verbose
        fprintf('%d\t%.6e\t%.6e\t%.2e\n', k-1, norm_f, step_size, cond_J);
    end
    
    % Check if step is too small (stagnation)
    if k > 1 && step_size < 1e-12 && norm_f > tol
        warning('Method stagnated - no progress');
        break;
    end
end

warning('Maximum iterations (%d) reached without convergence', maxiter);
history.iterations = maxiter;
history.x = history.x(:, 1:maxiter);
history.norm_f = history.norm_f(1:maxiter);

end

%% Helper function
function value = getfield_safe(s, field, default)
    if isfield(s, field)
        value = s.(field);
    else
        value = default;
    end
end</pre>
            </div>
            
            <div class="code-examples">
                <div class="example-box">
                    <h3>🔧 Usage Example</h3>
                    <div class="code-container">
<pre>% Define system: circle and line
function F = system_fun(x)
    F = [x(1)^2 + x(2)^2 - 1;  % Circle
         x(1) - x(2)];          % Line
end

function J = jacobian_fun(x)
    J = [2*x(1), 2*x(2);       % Derivatives
         1,      -1];          
end

% Solve with options
opts.tol = 1e-10;
opts.maxiter = 20;
opts.verbose = true;

x0 = [0.8; 0.2];
[sol, hist] = newton_system(...
    @system_fun, @jacobian_fun, x0, opts);

fprintf('\nSolution: x=%.10f, y=%.10f\n', ...
    sol(1), sol(2));
fprintf('Final error: %.2e\n', ...
    hist.norm_f(end));</pre>
                    </div>
                </div>
                
                <div class="example-box">
                    <h3>📊 Convergence Analysis</h3>
                    <div class="code-container">
<pre>% Plot convergence on log scale
figure('Position', [100 100 800 400]);

subplot(1,2,1);
semilogy(0:hist.iterations-1, ...
         hist.norm_f(1:hist.iterations), ...
         'o-', 'LineWidth', 2);
xlabel('Iteration');
ylabel('||F(x)||');
title('Newton Method Convergence');
grid on;

% Check convergence rate
if hist.iterations >= 3
    n = hist.iterations;
    conv_rate = log(hist.norm_f(n) / ...
                    hist.norm_f(n-1)) / ...
                log(hist.norm_f(n-1) / ...
                    hist.norm_f(n-2));
    fprintf('Convergence rate: %.2f\n', ...
            conv_rate);
    fprintf('(Quadratic = 2.0)\n');
end

% Plot solution path
subplot(1,2,2);
plot(hist.x(1,1:hist.iterations), ...
     hist.x(2,1:hist.iterations), ...
     'o-', 'LineWidth', 2);
xlabel('x'); ylabel('y');
title('Newton Method Path');
axis equal; grid on;</pre>
                    </div>
                </div>
            </div>
            
            <div class="example-box">
                <h3>🔢 Numerical Jacobian Alternative</h3>
                <p>When analytical Jacobian is hard to compute:</p>
                <div class="code-container">
<pre>function J = numerical_jacobian(fun, x, h)
% Compute Jacobian using finite differences
% h: step size (default 1e-8)

if nargin < 3, h = 1e-8; end

n = length(x);
F0 = feval(fun, x);
m = length(F0);
J = zeros(m, n);

for j = 1:n
    x_perturbed = x;
    x_perturbed(j) = x_perturbed(j) + h;
    F_perturbed = feval(fun, x_perturbed);
    J(:, j) = (F_perturbed - F0) / h;
end

end

% Usage
[sol, hist] = newton_system(...
    @system_fun, ...
    @(x) numerical_jacobian(@system_fun, x), ...
    x0, opts);</pre>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ===== SYSTEM DEFINITIONS =====
        const systems = {
            simple: {
                name: 'Simple System',
                equations: ['x² + y² - 1 = 0', 'x - y = 0'],
                f: (x, y) => [x*x + y*y - 1, x - y],
                jacobian: (x, y) => [[2*x, 2*y], [1, -1]],
                bounds: {xMin: -2, xMax: 2, yMin: -2, yMax: 2},
                contours: [
                    {type: 'circle', params: {cx: 0, cy: 0, r: 1}},
                    {type: 'line', params: {m: 1, b: 0}}
                ]
            },
            circle_line: {
                name: 'Circle & Line',
                equations: ['x² + y² - 1 = 0', 'x + y - 1 = 0'],
                f: (x, y) => [x*x + y*y - 1, x + y - 1],
                jacobian: (x, y) => [[2*x, 2*y], [1, 1]],
                bounds: {xMin: -2, xMax: 2, yMin: -2, yMax: 2},
                contours: [
                    {type: 'circle', params: {cx: 0, cy: 0, r: 1}},
                    {type: 'line', params: {m: -1, b: 1}}
                ]
            },
            nonlinear: {
                name: 'Complex Nonlinear',
                equations: ['(x-y)² - 1 = 0', 'eˣ - y - 2 = 0'],
                f: (x, y) => [(x-y)*(x-y) - 1, Math.exp(x) - y - 2],
                jacobian: (x, y) => [[2*(x-y), -2*(x-y)], [Math.exp(x), -1]],
                bounds: {xMin: -1.5, xMax: 2.5, yMin: -2.5, yMax: 4},
                contours: [
                    {type: 'custom', f: (x, y) => (x-y)*(x-y) - 1},
                    {type: 'custom', f: (x, y) => Math.exp(x) - y - 2}
                ]
            },
            ellipse_hyperbola: {
                name: 'Ellipse & Hyperbola',
                equations: ['x²/4 + y² - 1 = 0', 'xy - 1 = 0'],
                f: (x, y) => [x*x/4 + y*y - 1, x*y - 1],
                jacobian: (x, y) => [[x/2, 2*y], [y, x]],
                bounds: {xMin: -3, xMax: 3, yMin: -2.5, yMax: 2.5},
                contours: [
                    {type: 'ellipse', params: {cx: 0, cy: 0, rx: 2, ry: 1}},
                    {type: 'hyperbola', params: {k: 1}}
                ]
            },
            custom: {
                name: 'Custom System',
                equations: ['Custom f₁', 'Custom f₂'],
                f: null,
                jacobian: null,
                bounds: {xMin: -3, xMax: 3, yMin: -3, yMax: 3},
                contours: []
            }
        };

        // ===== NEWTON SOLVER CLASS =====
        class NewtonSolver {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.width = this.canvas.width;
                this.height = this.canvas.height;
                
                this.systemType = 'simple';
                this.useNumericalJacobian = false;
                this.showContours = true;
                this.showTangent = false;
                
                this.startX = 1.5;
                this.startY = 0.5;
                this.currentX = 1.5;
                this.currentY = 0.5;
                this.iteration = 0;
                this.path = [];
                this.errors = [];
                this.stepSizes = [];
                this.isAnimating = false;
                this.converged = false;
                this.diverged = false;
                
                // Viewport
                this.scale = 100;
                this.offsetX = this.width / 2;
                this.offsetY = this.height / 2;
                
                // Dragging
                this.isDragging = false;
                this.lastMouseX = 0;
                this.lastMouseY = 0;
                
                this.setupEvents();
                this.setupKeyboardShortcuts();
                this.reset();
                this.updateStatus('Ready! Select a system and click Next Step.', 'info');
            }
            
            setupEvents() {
                // System selection
                document.querySelectorAll('.system-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const target = e.target.closest('.system-btn');
                        document.querySelector('.system-btn.active')?.classList.remove('active');
                        target.classList.add('active');
                        this.systemType = target.dataset.system;
                        
                        // Show message about Jacobian for custom systems
                        if (this.systemType === 'custom' && !systems.custom.jacobian) {
                            this.updateStatus('Custom system loaded. Using numerical Jacobian.', 'info');
                        }
                        
                        this.reset();
                    });
                });
                
                // Input changes
                document.getElementById('startX').addEventListener('input', (e) => {
                    this.startX = parseFloat(e.target.value) || 0;
                    this.reset();
                });
                
                document.getElementById('startY').addEventListener('input', (e) => {
                    this.startY = parseFloat(e.target.value) || 0;
                    this.reset();
                });
                
                document.getElementById('useNumericalJacobian').addEventListener('change', (e) => {
                    this.useNumericalJacobian = e.target.checked;
                    this.updateStatus(this.useNumericalJacobian ? 
                        'Using numerical Jacobian' : 
                        'Using analytical Jacobian', 'info');
                });
                
                // Buttons
                document.getElementById('stepBtn').onclick = () => this.step();
                document.getElementById('resetBtn').onclick = () => this.reset();
                document.getElementById('animateBtn').onclick = () => this.toggleAnimation();
                document.getElementById('exportBtn').onclick = () => this.exportData();
                document.getElementById('resetZoomBtn').onclick = () => this.resetZoom();
                document.getElementById('toggleContoursBtn').onclick = () => this.toggleContours();
                document.getElementById('toggleTangentBtn').onclick = () => this.toggleTangent();
                
                // Canvas interactions
                this.setupCanvasInteractions();
            }
            
            setupCanvasInteractions() {
                // Zoom with wheel
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const rect = this.canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    
                    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                    
                    // Zoom towards mouse position
                    const worldX = (mouseX - this.offsetX) / this.scale;
                    const worldY = -(mouseY - this.offsetY) / this.scale;
                    
                    this.scale *= zoomFactor;
                    
                    this.offsetX = mouseX - worldX * this.scale;
                    this.offsetY = mouseY + worldY * this.scale;
                    
                    this.draw();
                });
                
                // Pan with drag
                this.canvas.addEventListener('mousedown', (e) => {
                    this.isDragging = true;
                    this.lastMouseX = e.offsetX;
                    this.lastMouseY = e.offsetY;
                    this.canvas.style.cursor = 'grabbing';
                });
                
                this.canvas.addEventListener('mousemove', (e) => {
                    if (!this.isDragging) return;
                    
                    const dx = e.offsetX - this.lastMouseX;
                    const dy = e.offsetY - this.lastMouseY;
                    
                    this.offsetX += dx;
                    this.offsetY += dy;
                    
                    this.lastMouseX = e.offsetX;
                    this.lastMouseY = e.offsetY;
                    
                    this.draw();
                });
                
                this.canvas.addEventListener('mouseup', () => {
                    this.isDragging = false;
                    this.canvas.style.cursor = 'grab';
                });
                
                this.canvas.addEventListener('mouseleave', () => {
                    this.isDragging = false;
                    this.canvas.style.cursor = 'grab';
                });
            }
            
            setupKeyboardShortcuts() {
                document.addEventListener('keydown', (e) => {
                    // Only respond when simulation tab is active
                    if (!document.getElementById('simulation').classList.contains('active')) return;
                    
                    if (e.key === 'n' || e.key === 'N' || e.key === ' ') {
                        e.preventDefault();
                        this.step();
                    } else if (e.key === 'r' || e.key === 'R') {
                        e.preventDefault();
                        this.reset();
                    } else if (e.key === 'a' || e.key === 'A') {
                        e.preventDefault();
                        this.toggleAnimation();
                    } else if (e.key === 'e' || e.key === 'E') {
                        e.preventDefault();
                        this.exportData();
                    } else if (e.key === 'm' || e.key === 'M') {
                        e.preventDefault();
                        const mathDisplay = document.getElementById('mathDisplay');
                        mathDisplay.style.display = mathDisplay.style.display === 'none' ? 'block' : 'none';
                    }
                });
            }
            
            getSystemValue(x, y) {
                const system = systems[this.systemType];
                return system.f(x, y);
            }
            
            getJacobian(x, y) {
                const system = systems[this.systemType];
                
                // If using numerical Jacobian option OR if analytical Jacobian is not available
                if (this.useNumericalJacobian || !system.jacobian) {
                    return this.getNumericalJacobian(x, y);
                }
                
                return system.jacobian(x, y);
            }
            
            getNumericalJacobian(x, y, h = 1e-8) {
                const F = this.getSystemValue(x, y);
                const Fx = this.getSystemValue(x + h, y);
                const Fy = this.getSystemValue(x, y + h);
                
                return [
                    [(Fx[0] - F[0])/h, (Fy[0] - F[0])/h],
                    [(Fx[1] - F[1])/h, (Fy[1] - F[1])/h]
                ];
            }
            
            determinant2x2(matrix) {
                const [[a, b], [c, d]] = matrix;
                return a*d - b*c;
            }
            
            invertMatrix2x2(matrix) {
                const [[a, b], [c, d]] = matrix;
                const det = this.determinant2x2(matrix);
                if (Math.abs(det) < 1e-12) throw new Error('Singular matrix');
                return [[d/det, -b/det], [-c/det, a/det]];
            }
            
            matrixVectorMultiply(matrix, vector) {
                const [[a, b], [c, d]] = matrix;
                const [x, y] = vector;
                return [a*x + b*y, c*x + d*y];
            }
            
            matrixConditionNumber(matrix) {
                const [[a, b], [c, d]] = matrix;
                const det = Math.abs(a*d - b*c);
                const norm = Math.sqrt(a*a + b*b + c*c + d*d);
                if (det < 1e-15) return Infinity;
                const invNorm = Math.sqrt((d*d + b*b + c*c + a*a) / (det*det));
                return norm * invNorm;
            }
            
            step() {
                if (this.converged) {
                    this.updateStatus('Already converged!', 'success');
                    return;
                }
                
                if (this.diverged) {
                    this.updateStatus('Method has diverged. Try a different starting point.', 'error');
                    return;
                }
                
                try {
                    const F = this.getSystemValue(this.currentX, this.currentY);
                    const J = this.getJacobian(this.currentX, this.currentY);
                    
                    const residualNorm = Math.sqrt(F[0]*F[0] + F[1]*F[1]);
                    
                    // Check if already converged
                    if (residualNorm < 1e-8) {
                        this.converged = true;
                        this.updateStatus(`Converged in ${this.iteration} iterations!`, 'success');
                        this.stopAnimation();
                        return;
                    }
                    
                    // Check condition number
                    const condJ = this.matrixConditionNumber(J);
                    if (condJ > 1e12) {
                        this.diverged = true;
                        this.updateStatus('Jacobian is nearly singular! Method cannot proceed.', 'error');
                        this.stopAnimation();
                        return;
                    }
                    
                    const det = this.determinant2x2(J);
                    if (Math.abs(det) < 1e-12) {
                        this.diverged = true;
                        this.updateStatus('Singular matrix! Try different starting point.', 'error');
                        this.stopAnimation();
                        return;
                    }
                    
                    const JInv = this.invertMatrix2x2(J);
                    const delta = this.matrixVectorMultiply(JInv, F);
                    
                    const newX = this.currentX - delta[0];
                    const newY = this.currentY - delta[1];
                    
                    // Check for divergence
                    if (Math.abs(newX) > 100 || Math.abs(newY) > 100) {
                        this.diverged = true;
                        this.updateStatus('Method diverging! Solution escaping to infinity.', 'error');
                        this.stopAnimation();
                        return;
                    }
                    
                    // Check for stagnation
                    const stepSize = Math.sqrt(delta[0]*delta[0] + delta[1]*delta[1]);
                    if (this.iteration > 0 && stepSize < 1e-10 && residualNorm > 1e-6) {
                        this.diverged = true;
                        this.updateStatus('Method stuck! No progress being made.', 'warning');
                        this.stopAnimation();
                        return;
                    }
                    
                    this.currentX = newX;
                    this.currentY = newY;
                    this.iteration++;
                    this.path.push({x: this.currentX, y: this.currentY});
                    this.errors.push(residualNorm);
                    this.stepSizes.push(stepSize);
                    
                    this.displayStepMath(F, J, JInv, delta, residualNorm, condJ);
                    this.updateInfo();
                    this.updateConvergenceChart();
                    this.draw();
                    
                    this.updateStatus(
                        `Iteration ${this.iteration}: ||F|| = ${residualNorm.toExponential(3)}, Step = ${stepSize.toExponential(3)}`,
                        'info'
                    );
                    
                } catch (error) {
                    this.updateStatus(`Error: ${error.message}`, 'error');
                    this.stopAnimation();
                }
            }
            
            displayStepMath(F, J, JInv, delta, residualNorm, condJ) {
                const mathDisplay = document.getElementById('mathDisplay');
                
                let jacobianNote = '';
                if (this.systemType === 'custom') {
                    if (systems.custom.jacobian && !this.useNumericalJacobian) {
                        jacobianNote = ' (Analytical - Custom)';
                    } else {
                        jacobianNote = ' (Numerical - Custom)';
                    }
                } else if (this.useNumericalJacobian) {
                    jacobianNote = ' (Numerical)';
                } else {
                    jacobianNote = ' (Analytical)';
                }
                
                mathDisplay.innerHTML = `
                    <h4>📐 Iteration ${this.iteration} Mathematics</h4>
                    
                    <p><strong>Current Point:</strong></p>
                    <div class="formula-box">x = [${this.currentX.toFixed(6)}, ${this.currentY.toFixed(6)}]ᵀ</div>
                    
                    <p><strong>Function Values:</strong></p>
                    <div class="formula-box">
                        F(x) = [${F[0].toFixed(6)}, ${F[1].toFixed(6)}]ᵀ<br>
                        ||F(x)|| = ${residualNorm.toExponential(6)}
                    </div>
                    
                    <p><strong>Jacobian Matrix${jacobianNote}:</strong></p>
                    <div class="formula-box">
                        J = [${J[0][0].toFixed(6)}&nbsp;&nbsp;${J[0][1].toFixed(6)}]<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;[${J[1][0].toFixed(6)}&nbsp;&nbsp;${J[1][1].toFixed(6)}]<br>
                        <br>
                        det(J) = ${this.determinant2x2(J).toFixed(6)}<br>
                        cond(J) ≈ ${condJ.toExponential(3)}
                    </div>
                    
                    <p><strong>Newton Step (Δx = -J⁻¹F):</strong></p>
                    <div class="formula-box">
                        Δx = [${(-delta[0]).toFixed(6)}, ${(-delta[1]).toFixed(6)}]ᵀ<br>
                        ||Δx|| = ${Math.sqrt(delta[0]*delta[0] + delta[1]*delta[1]).toExponential(6)}
                    </div>
                    
                    <p><strong>Updated Position:</strong></p>
                    <div class="formula-box">
                        x⁽${this.iteration}⁾ = x⁽${this.iteration-1}⁾ + Δx = [${(this.currentX-delta[0]).toFixed(6)}, ${(this.currentY-delta[1]).toFixed(6)}]ᵀ
                    </div>
                `;
            }
            
            updateConvergenceChart() {
                if (this.errors.length < 2) return;
                
                const canvas = document.getElementById('convergenceChart');
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                
                ctx.clearRect(0, 0, width, height);
                
                // Find min/max for scaling
                const maxError = Math.max(...this.errors);
                const minError = Math.min(...this.errors.filter(e => e > 0));
                const logMax = Math.log10(maxError);
                const logMin = Math.log10(minError);
                
                // Draw axes
                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(50, height - 30);
                ctx.lineTo(width - 20, height - 30);
                ctx.moveTo(50, 20);
                ctx.lineTo(50, height - 30);
                ctx.stroke();
                
                // Draw error curve
                ctx.strokeStyle = '#4facfe';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let i = 0; i < this.errors.length; i++) {
                    const x = 50 + (i / (this.errors.length - 1)) * (width - 70);
                    const logError = Math.log10(this.errors[i]);
                    const y = height - 30 - ((logError - logMin) / (logMax - logMin)) * (height - 50);
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
                
                // Draw points
                ctx.fillStyle = '#4facfe';
                for (let i = 0; i < this.errors.length; i++) {
                    const x = 50 + (i / (this.errors.length - 1)) * (width - 70);
                    const logError = Math.log10(this.errors[i]);
                    const y = height - 30 - ((logError - logMin) / (logMax - logMin)) * (height - 50);
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, 2 * Math.PI);
                    ctx.fill();
                }
                
                // Labels
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.fillText('Iteration', width/2, height - 5);
                ctx.save();
                ctx.translate(15, height/2);
                ctx.rotate(-Math.PI/2);
                ctx.fillText('||F(x)|| (log scale)', 0, 0);
                ctx.restore();
                
                // Calculate convergence rate
                if (this.errors.length >= 3) {
                    const n = this.errors.length - 1;
                    const ratio = Math.log(this.errors[n] / this.errors[n-1]) / 
                                 Math.log(this.errors[n-1] / this.errors[n-2]);
                    document.getElementById('convRate').textContent = ratio.toFixed(3);
                }
            }
            
            reset() {
                this.currentX = this.startX;
                this.currentY = this.startY;
                this.iteration = 0;
                this.path = [{x: this.currentX, y: this.currentY}];
                this.errors = [];
                this.stepSizes = [];
                this.converged = false;
                this.diverged = false;
                this.stopAnimation();
                
                // Initial evaluation
                const F = this.getSystemValue(this.currentX, this.currentY);
                const residualNorm = Math.sqrt(F[0]*F[0] + F[1]*F[1]);
                this.errors.push(residualNorm);
                
                this.updateInfo();
                this.updateConvergenceChart();
                this.draw();
                
                document.getElementById('mathDisplay').innerHTML = `
                    <h4>📐 Step-by-Step Mathematics</h4>
                    <p style="color: #666;">Take a step to see the mathematics...</p>
                `;
                
                this.updateStatus(`Reset to (${this.currentX}, ${this.currentY})`, 'info');
            }
            
            resetZoom() {
                this.scale = 100;
                this.offsetX = this.width / 2;
                this.offsetY = this.height / 2;
                this.draw();
            }
            
            toggleContours() {
                this.showContours = !this.showContours;
                this.draw();
                document.getElementById('toggleContoursBtn').textContent = 
                    this.showContours ? 'Hide Contours' : 'Show Contours';
            }
            
            toggleTangent() {
                this.showTangent = !this.showTangent;
                this.draw();
                document.getElementById('toggleTangentBtn').textContent = 
                    this.showTangent ? 'Hide Tangent' : 'Show Tangent';
            }
            
            updateInfo() {
                document.getElementById('iteration').textContent = this.iteration;
                document.getElementById('currentX').textContent = this.currentX.toFixed(6);
                document.getElementById('currentY').textContent = this.currentY.toFixed(6);
                
                const F = this.getSystemValue(this.currentX, this.currentY);
                const residualNorm = Math.sqrt(F[0]*F[0] + F[1]*F[1]);
                document.getElementById('error').textContent = residualNorm.toExponential(6);
                document.getElementById('f1').textContent = F[0].toFixed(6);
                document.getElementById('f2').textContent = F[1].toFixed(6);
                
                if (this.stepSizes.length > 0) {
                    const lastStep = this.stepSizes[this.stepSizes.length - 1];
                    document.getElementById('stepSize').textContent = lastStep.toExponential(6);
                } else {
                    document.getElementById('stepSize').textContent = '--';
                }
            }
            
            updateStatus(message, type = 'info') {
                const statusDiv = document.getElementById('statusMessage');
                statusDiv.textContent = message;
                statusDiv.className = 'status-message ' + type;
            }
            
            toggleAnimation() {
                if (this.isAnimating) {
                    this.stopAnimation();
                } else {
                    this.startAnimation();
                }
            }
            
            startAnimation() {
                if (this.converged || this.diverged) {
                    this.reset();
                }
                this.isAnimating = true;
                document.getElementById('animateBtn').textContent = '⏸️ Stop (A)';
                document.getElementById('stepBtn').disabled = true;
                this.animate();
            }
            
            stopAnimation() {
                this.isAnimating = false;
                document.getElementById('animateBtn').textContent = '⚡ Auto Solve (A)';
                document.getElementById('stepBtn').disabled = false;
            }
            
            animate() {
                if (!this.isAnimating) return;
                
                this.step();
                
                if (this.converged || this.diverged || this.iteration >= 50) {
                    this.stopAnimation();
                    return;
                }
                
                setTimeout(() => this.animate(), 800);
            }
            
            exportData() {
                const data = {
                    system: this.systemType,
                    systemName: systems[this.systemType].name,
                    equations: systems[this.systemType].equations,
                    startPoint: {x: this.startX, y: this.startY},
                    iterations: this.iteration,
                    converged: this.converged,
                    diverged: this.diverged,
                    path: this.path,
                    errors: this.errors,
                    stepSizes: this.stepSizes,
                    finalPoint: {
                        x: this.currentX,
                        y: this.currentY
                    },
                    finalError: this.errors[this.errors.length - 1],
                    useNumericalJacobian: this.useNumericalJacobian,
                    timestamp: new Date().toISOString()
                };
                
                const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `newton_method_${this.systemType}_${Date.now()}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                this.updateStatus('Data exported successfully!', 'success');
            }
            
            mathToScreen(mathX, mathY) {
                return {
                    x: mathX * this.scale + this.offsetX,
                    y: -mathY * this.scale + this.offsetY
                };
            }
            
            screenToMath(screenX, screenY) {
                return {
                    x: (screenX - this.offsetX) / this.scale,
                    y: -(screenY - this.offsetY) / this.scale
                };
            }
            
            draw() {
                this.ctx.clearRect(0, 0, this.width, this.height);
                this.drawGrid();
                if (this.showContours) {
                    this.drawContours();
                }
                if (this.showTangent && this.path.length > 0) {
                    this.drawTangentPlane();
                }
                this.drawPath();
            }
            
            drawGrid() {
                const bounds = systems[this.systemType].bounds;
                
                // Axes
                this.ctx.strokeStyle = '#999';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                const originScreen = this.mathToScreen(0, 0);
                this.ctx.moveTo(0, originScreen.y);
                this.ctx.lineTo(this.width, originScreen.y);
                this.ctx.moveTo(originScreen.x, 0);
                this.ctx.lineTo(originScreen.x, this.height);
                this.ctx.stroke();
                
                // Grid
                this.ctx.strokeStyle = '#f0f0f0';
                this.ctx.lineWidth = 1;
                
                const gridStep = this.scale > 50 ? 1 : this.scale > 20 ? 2 : 5;
                
                for (let x = Math.floor(bounds.xMin); x <= Math.ceil(bounds.xMax); x += gridStep) {
                    if (x === 0) continue;
                    const screenPos = this.mathToScreen(x, 0);
                    if (screenPos.x >= 0 && screenPos.x <= this.width) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(screenPos.x, 0);
                        this.ctx.lineTo(screenPos.x, this.height);
                        this.ctx.stroke();
                        
                        this.ctx.fillStyle = '#666';
                        this.ctx.font = '12px Arial';
                        this.ctx.fillText(x.toString(), screenPos.x - 5, originScreen.y + 15);
                    }
                }
                
                for (let y = Math.floor(bounds.yMin); y <= Math.ceil(bounds.yMax); y += gridStep) {
                    if (y === 0) continue;
                    const screenPos = this.mathToScreen(0, y);
                    if (screenPos.y >= 0 && screenPos.y <= this.height) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(0, screenPos.y);
                        this.ctx.lineTo(this.width, screenPos.y);
                        this.ctx.stroke();
                        
                        this.ctx.fillStyle = '#666';
                        this.ctx.font = '12px Arial';
                        this.ctx.fillText(y.toString(), originScreen.x + 5, screenPos.y + 5);
                    }
                }
            }
            
            drawContours() {
                const system = systems[this.systemType];
                const bounds = system.bounds;
                
                // Draw f1 = 0 contour (red)
                this.ctx.strokeStyle = '#e74c3c';
                this.ctx.lineWidth = 3;
                this.drawContourForFunction(0, system, bounds);
                
                // Draw f2 = 0 contour (green)
                this.ctx.strokeStyle = '#2ecc71';
                this.ctx.lineWidth = 3;
                this.drawContourForFunction(1, system, bounds);
                
                // Legend
                this.ctx.font = 'bold 14px Arial';
                this.ctx.fillStyle = '#e74c3c';
                this.ctx.fillText('f₁(x,y) = 0', 10, 25);
                this.ctx.fillStyle = '#2ecc71';
                this.ctx.fillText('f₂(x,y) = 0', 10, 45);
            }
            
            drawContourForFunction(funcIndex, system, bounds) {
                // Try to detect if this is a simple line: ax + by + c = 0
                const isLine = this.tryDrawLine(funcIndex, system, bounds);
                
                if (!isLine) {
                    // Fall back to marching squares for complex curves
                    this.drawImplicitCurve((x, y) => system.f(x, y)[funcIndex], bounds, 0);
                }
            }
            
            tryDrawLine(funcIndex, system, bounds) {
                // Sample three points to check if it's a line
                try {
                    const x1 = bounds.xMin, y1 = 0;
                    const x2 = 0, y2 = bounds.yMin;
                    const x3 = bounds.xMax, y3 = bounds.yMax;
                    
                    const f1 = system.f(x1, y1)[funcIndex];
                    const f2 = system.f(x2, y2)[funcIndex];
                    const f3 = system.f(x3, y3)[funcIndex];
                    
                    // For a line ax + by + c = 0, we can find the coefficients
                    // Try to find where the function crosses zero
                    const testPoints = [];
                    
                    // Sample along edges to find zero crossings
                    for (let t = 0; t <= 1; t += 0.01) {
                        // Top edge
                        let x = bounds.xMin + t * (bounds.xMax - bounds.xMin);
                        let y = bounds.yMax;
                        let val = system.f(x, y)[funcIndex];
                        if (Math.abs(val) < 0.01) testPoints.push({x, y});
                        
                        // Bottom edge
                        y = bounds.yMin;
                        val = system.f(x, y)[funcIndex];
                        if (Math.abs(val) < 0.01) testPoints.push({x, y});
                        
                        // Left edge
                        x = bounds.xMin;
                        y = bounds.yMin + t * (bounds.yMax - bounds.yMin);
                        val = system.f(x, y)[funcIndex];
                        if (Math.abs(val) < 0.01) testPoints.push({x, y});
                        
                        // Right edge
                        x = bounds.xMax;
                        val = system.f(x, y)[funcIndex];
                        if (Math.abs(val) < 0.01) testPoints.push({x, y});
                    }
                    
                    // Also sample through the middle
                    for (let t = 0; t <= 1; t += 0.005) {
                        const x = bounds.xMin + t * (bounds.xMax - bounds.xMin);
                        const y = bounds.yMin + t * (bounds.yMax - bounds.yMin);
                        const val = system.f(x, y)[funcIndex];
                        if (Math.abs(val) < 0.01) testPoints.push({x, y});
                    }
                    
                    if (testPoints.length >= 2) {
                        // Check if points are collinear (it's a line)
                        let isLine = true;
                        if (testPoints.length > 2) {
                            const dx1 = testPoints[1].x - testPoints[0].x;
                            const dy1 = testPoints[1].y - testPoints[0].y;
                            
                            for (let i = 2; i < Math.min(testPoints.length, 10); i++) {
                                const dx2 = testPoints[i].x - testPoints[0].x;
                                const dy2 = testPoints[i].y - testPoints[0].y;
                                
                                // Check if cross product is near zero (collinear)
                                const cross = dx1 * dy2 - dy1 * dx2;
                                if (Math.abs(cross) > 0.1) {
                                    isLine = false;
                                    break;
                                }
                            }
                        }
                        
                        if (isLine && testPoints.length >= 2) {
                            // Draw the line through all points
                            this.ctx.beginPath();
                            
                            // Sort points to draw a connected line
                            testPoints.sort((a, b) => {
                                const distA = Math.sqrt(a.x * a.x + a.y * a.y);
                                const distB = Math.sqrt(b.x * b.x + b.y * b.y);
                                return distA - distB;
                            });
                            
                            const start = this.mathToScreen(testPoints[0].x, testPoints[0].y);
                            this.ctx.moveTo(start.x, start.y);
                            
                            for (let i = 1; i < testPoints.length; i++) {
                                const screen = this.mathToScreen(testPoints[i].x, testPoints[i].y);
                                this.ctx.lineTo(screen.x, screen.y);
                            }
                            
                            this.ctx.stroke();
                            return true;
                        }
                    }
                } catch (e) {
                    // Fall through to marching squares
                }
                
                return false;
            }
            
            drawImplicitCurve(func, bounds, level) {
                const resolution = 300;
                const dx = (bounds.xMax - bounds.xMin) / resolution;
                const dy = (bounds.yMax - bounds.yMin) / resolution;
                
                // Store all contour points first
                const contourSegments = [];
                
                for (let i = 0; i < resolution; i++) {
                    for (let j = 0; j < resolution; j++) {
                        const x1 = bounds.xMin + i * dx;
                        const y1 = bounds.yMin + j * dy;
                        const x2 = x1 + dx;
                        const y2 = y1 + dy;
                        
                        try {
                            const v1 = func(x1, y1) - level;
                            const v2 = func(x2, y1) - level;
                            const v3 = func(x2, y2) - level;
                            const v4 = func(x1, y2) - level;
                            
                            // Marching squares for cleaner contours
                            const edges = [];
                            
                            if (v1 * v2 < 0) {
                                const t = v1 / (v1 - v2);
                                edges.push({x: x1 + t * dx, y: y1});
                            }
                            if (v2 * v3 < 0) {
                                const t = v2 / (v2 - v3);
                                edges.push({x: x2, y: y1 + t * dy});
                            }
                            if (v3 * v4 < 0) {
                                const t = v3 / (v3 - v4);
                                edges.push({x: x2 - t * dx, y: y2});
                            }
                            if (v4 * v1 < 0) {
                                const t = v4 / (v4 - v1);
                                edges.push({x: x1, y: y2 - t * dy});
                            }
                            
                            // Draw segments between pairs
                            if (edges.length >= 2) {
                                contourSegments.push([edges[0], edges[1]]);
                            }
                        } catch (e) {
                            // Skip points where function is undefined
                        }
                    }
                }
                
                // Draw all segments
                contourSegments.forEach(segment => {
                    const screen1 = this.mathToScreen(segment[0].x, segment[0].y);
                    const screen2 = this.mathToScreen(segment[1].x, segment[1].y);
                    
                    if (screen1.x >= -100 && screen1.x <= this.width + 100 &&
                        screen1.y >= -100 && screen1.y <= this.height + 100 &&
                        screen2.x >= -100 && screen2.x <= this.width + 100 &&
                        screen2.y >= -100 && screen2.y <= this.height + 100) {
                        
                        this.ctx.beginPath();
                        this.ctx.moveTo(screen1.x, screen1.y);
                        this.ctx.lineTo(screen2.x, screen2.y);
                        this.ctx.stroke();
                    }
                });
            }
            
            drawTangentPlane() {
                if (this.path.length === 0) return;
                
                const current = this.path[this.path.length - 1];
                const J = this.getJacobian(current.x, current.y);
                const F = this.getSystemValue(current.x, current.y);
                
                // Draw linear approximations
                this.ctx.strokeStyle = 'rgba(155, 89, 182, 0.6)';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([5, 5]);
                
                // For f1: linearization is f1(x0,y0) + J11*(x-x0) + J12*(y-y0) = 0
                // For f2: linearization is f2(x0,y0) + J21*(x-x0) + J22*(y-y0) = 0
                
                // Draw tangent line for f1
                const J11 = J[0][0], J12 = J[0][1];
                if (Math.abs(J12) > 1e-10) {
                    this.ctx.beginPath();
                    for (let x = current.x - 2; x <= current.x + 2; x += 0.1) {
                        const y = current.y - (F[0] + J11 * (x - current.x)) / J12;
                        const screen = this.mathToScreen(x, y);
                        if (x === current.x - 2) {
                            this.ctx.moveTo(screen.x, screen.y);
                        } else {
                            this.ctx.lineTo(screen.x, screen.y);
                        }
                    }
                    this.ctx.stroke();
                }
                
                this.ctx.setLineDash([]);
            }
            
            drawPath() {
                if (this.path.length === 0) return;
                
                // Draw path lines
                if (this.path.length > 1) {
                    this.ctx.strokeStyle = '#9b59b6';
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([5, 5]);
                    
                    this.ctx.beginPath();
                    const start = this.mathToScreen(this.path[0].x, this.path[0].y);
                    this.ctx.moveTo(start.x, start.y);
                    
                    for (let i = 1; i < this.path.length; i++) {
                        const point = this.mathToScreen(this.path[i].x, this.path[i].y);
                        this.ctx.lineTo(point.x, point.y);
                    }
                    
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                }
                
                // Draw points
                this.path.forEach((point, index) => {
                    const screen = this.mathToScreen(point.x, point.y);
                    
                    if (screen.x >= -50 && screen.x <= this.width + 50 && 
                        screen.y >= -50 && screen.y <= this.height + 50) {
                        
                        let size, color, label;
                        
                        if (index === 0) {
                            size = 10;
                            color = '#e67e22';
                            label = 'Start';
                        } else if (index === this.path.length - 1) {
                            size = 12;
                            color = this.converged ? '#2ecc71' : '#e74c3c';
                            label = this.converged ? '✓' : index;
                        } else {
                            size = 7;
                            color = '#9b59b6';
                            label = index;
                        }
                        
                        this.ctx.fillStyle = color;
                        this.ctx.beginPath();
                        this.ctx.arc(screen.x, screen.y, size, 0, 2 * Math.PI);
                        this.ctx.fill();
                        
                        this.ctx.strokeStyle = 'white';
                        this.ctx.lineWidth = 2;
                        this.ctx.stroke();
                        
                        // Label
                        if (typeof label === 'number' || index === 0) {
                            this.ctx.fillStyle = '#333';
                            this.ctx.font = 'bold 11px Arial';
                            this.ctx.fillText(label.toString(), screen.x + 15, screen.y - 10);
                        } else if (label === '✓') {
                            this.ctx.fillStyle = 'white';
                            this.ctx.font = 'bold 16px Arial';
                            this.ctx.fillText(label, screen.x - 5, screen.y + 6);
                        }
                    }
                });
            }
        }

        // ===== COMPARISON MODE =====
        class ComparisonMode {
            constructor() {
                this.canvas = document.getElementById('comparisonCanvas');
                this.chartCanvas = document.getElementById('comparisonChart');
                this.selectedStarts = [];
                this.results = [];
                this.systemType = 'simple';
                
                this.setupEvents();
            }
            
            setupEvents() {
                document.querySelectorAll('#startingPointsGrid .comparison-item').forEach(item => {
                    item.addEventListener('click', (e) => {
                        e.target.classList.toggle('active');
                    });
                });
                
                document.getElementById('runComparisonBtn').onclick = () => this.runComparison();
                document.getElementById('clearComparisonBtn').onclick = () => this.clearComparison();
            }
            
            runComparison() {
                // Get selected starting points
                this.selectedStarts = [];
                document.querySelectorAll('#startingPointsGrid .comparison-item.active').forEach(item => {
                    const coords = item.dataset.start.split(',').map(parseFloat);
                    this.selectedStarts.push({x: coords[0], y: coords[1], label: item.querySelector('strong').textContent});
                });
                
                if (this.selectedStarts.length === 0) {
                    alert('Please select at least one starting point');
                    return;
                }
                
                // Get current system type from simulation tab
                const activeSystem = document.querySelector('#simulation .system-btn.active');
                this.systemType = activeSystem ? activeSystem.dataset.system : 'simple';
                
                // Run Newton's method for each starting point
                this.results = [];
                for (const start of this.selectedStarts) {
                    const result = this.solveNewton(start.x, start.y);
                    result.label = start.label;
                    result.start = start;
                    this.results.push(result);
                }
                
                // Draw results
                this.drawComparisonPaths();
                this.drawComparisonChart();
                this.displayComparisonResults();
            }
            
            solveNewton(x0, y0, maxIter = 50, tol = 1e-8) {
                const system = systems[this.systemType];
                let x = x0, y = y0;
                const path = [{x, y}];
                const errors = [];
                let converged = false;
                let iterations = 0;
                
                for (let i = 0; i < maxIter; i++) {
                    const F = system.f(x, y);
                    const J = system.jacobian(x, y);
                    
                    const residualNorm = Math.sqrt(F[0]*F[0] + F[1]*F[1]);
                    errors.push(residualNorm);
                    
                    if (residualNorm < tol) {
                        converged = true;
                        iterations = i;
                        break;
                    }
                    
                    // Check for singular matrix
                    const det = J[0][0]*J[1][1] - J[0][1]*J[1][0];
                    if (Math.abs(det) < 1e-12) break;
                    
                    // Newton step
                    const JInv = [[J[1][1]/det, -J[0][1]/det], [-J[1][0]/det, J[0][0]/det]];
                    const dx = -(JInv[0][0]*F[0] + JInv[0][1]*F[1]);
                    const dy = -(JInv[1][0]*F[0] + JInv[1][1]*F[1]);
                    
                    x += dx;
                    y += dy;
                    path.push({x, y});
                    
                    // Check for divergence
                    if (Math.abs(x) > 100 || Math.abs(y) > 100) break;
                    
                    iterations = i + 1;
                }
                
                return {path, errors, converged, iterations, finalPoint: {x, y}};
            }
            
            drawComparisonPaths() {
                const canvas = this.canvas;
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                
                ctx.clearRect(0, 0, width, height);
                
                // Setup viewport
                const scale = 100;
                const offsetX = width / 2;
                const offsetY = height / 2;
                
                const mathToScreen = (x, y) => ({
                    x: x * scale + offsetX,
                    y: -y * scale + offsetY
                });
                
                // Draw axes
                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, offsetY);
                ctx.lineTo(width, offsetY);
                ctx.moveTo(offsetX, 0);
                ctx.lineTo(offsetX, height);
                ctx.stroke();
                
                // Draw contours
                const system = systems[this.systemType];
                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.3;
                this.drawSimpleContour(ctx, mathToScreen, system, 0, scale);
                ctx.globalAlpha = 1.0;
                
                // Draw paths with different colors
                const colors = ['#9b59b6', '#3498db', '#e67e22', '#16a085'];
                
                this.results.forEach((result, index) => {
                    const color = colors[index % colors.length];
                    
                    // Draw path
                    if (result.path.length > 1) {
                        ctx.strokeStyle = color;
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 5]);
                        ctx.beginPath();
                        
                        result.path.forEach((point, i) => {
                            const screen = mathToScreen(point.x, point.y);
                            if (i === 0) {
                                ctx.moveTo(screen.x, screen.y);
                            } else {
                                ctx.lineTo(screen.x, screen.y);
                            }
                        });
                        
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }
                    
                    // Draw points
                    result.path.forEach((point, i) => {
                        const screen = mathToScreen(point.x, point.y);
                        const size = i === 0 ? 8 : i === result.path.length - 1 ? 10 : 5;
                        
                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.arc(screen.x, screen.y, size, 0, 2 * Math.PI);
                        ctx.fill();
                        
                        if (i === 0) {
                            ctx.fillStyle = '#333';
                            ctx.font = 'bold 12px Arial';
                            ctx.fillText(result.label, screen.x + 12, screen.y - 8);
                        }
                    });
                });
            }
            
            drawSimpleContour(ctx, mathToScreen, system, level, scale) {
                // Draw clean contour lines without shading
                const bounds = system.bounds;
                const resolution = 200;
                const dx = (bounds.xMax - bounds.xMin) / resolution;
                const dy = (bounds.yMax - bounds.yMin) / resolution;
                
                for (let i = 0; i < resolution - 1; i++) {
                    for (let j = 0; j < resolution - 1; j++) {
                        const x1 = bounds.xMin + i * dx;
                        const y1 = bounds.yMin + j * dy;
                        const x2 = x1 + dx;
                        const y2 = y1 + dy;
                        
                        try {
                            const f1_1 = system.f(x1, y1);
                            const f1_2 = system.f(x2, y1);
                            const f1_3 = system.f(x2, y2);
                            const f1_4 = system.f(x1, y2);
                            
                            // Check for zero crossing in f1
                            if ((f1_1[0] * f1_2[0] < 0) || (f1_2[0] * f1_3[0] < 0) || 
                                (f1_3[0] * f1_4[0] < 0) || (f1_4[0] * f1_1[0] < 0)) {
                                const screen = mathToScreen((x1 + x2) / 2, (y1 + y2) / 2);
                                ctx.strokeStyle = '#e74c3c';
                                ctx.beginPath();
                                ctx.arc(screen.x, screen.y, 1, 0, 2 * Math.PI);
                                ctx.stroke();
                            }
                            
                            // Check for zero crossing in f2
                            if ((f1_1[1] * f1_2[1] < 0) || (f1_2[1] * f1_3[1] < 0) || 
                                (f1_3[1] * f1_4[1] < 0) || (f1_4[1] * f1_1[1] < 0)) {
                                const screen = mathToScreen((x1 + x2) / 2, (y1 + y2) / 2);
                                ctx.strokeStyle = '#2ecc71';
                                ctx.beginPath();
                                ctx.arc(screen.x, screen.y, 1, 0, 2 * Math.PI);
                                ctx.stroke();
                            }
                        } catch (e) {}
                    }
                }
            }
            
            drawComparisonChart() {
                const canvas = this.chartCanvas;
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                
                ctx.clearRect(0, 0, width, height);
                
                if (this.results.length === 0) return;
                
                // Find global min/max
                let maxError = -Infinity;
                let minError = Infinity;
                let maxIter = 0;
                
                this.results.forEach(result => {
                    result.errors.forEach(e => {
                        if (e > 0) {
                            maxError = Math.max(maxError, e);
                            minError = Math.min(minError, e);
                        }
                    });
                    maxIter = Math.max(maxIter, result.errors.length);
                });
                
                const logMax = Math.log10(maxError);
                const logMin = Math.log10(minError);
                
                // Draw axes
                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(50, height - 30);
                ctx.lineTo(width - 20, height - 30);
                ctx.moveTo(50, 20);
                ctx.lineTo(50, height - 30);
                ctx.stroke();
                
                // Draw curves
                const colors = ['#9b59b6', '#3498db', '#e67e22', '#16a085'];
                
                this.results.forEach((result, index) => {
                    const color = colors[index % colors.length];
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    
                    result.errors.forEach((error, i) => {
                        const x = 50 + (i / Math.max(maxIter - 1, 1)) * (width - 70);
                        const logError = Math.log10(error);
                        const y = height - 30 - ((logError - logMin) / Math.max(logMax - logMin, 1)) * (height - 50);
                        
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    });
                    
                    ctx.stroke();
                    
                    // Draw legend
                    const legendY = 30 + index * 20;
                    ctx.fillStyle = color;
                    ctx.fillRect(width - 150, legendY, 15, 15);
                    ctx.fillStyle = '#333';
                    ctx.font = '12px Arial';
                    ctx.fillText(result.label, width - 130, legendY + 12);
                });
                
                // Labels
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.fillText('Iteration', width/2 - 20, height - 5);
                ctx.save();
                ctx.translate(15, height/2);
                ctx.rotate(-Math.PI/2);
                ctx.fillText('||F(x)|| (log)', 0, 0);
                ctx.restore();
            }
            
            displayComparisonResults() {
                const resultsDiv = document.getElementById('comparisonResults');
                let html = '<h4>Comparison Summary</h4>';
                
                this.results.forEach((result, index) => {
                    const status = result.converged ? '✓ Converged' : '✗ Did not converge';
                    const color = result.converged ? '#2ecc71' : '#e74c3c';
                    
                    html += `
                        <div style="background: white; padding: 15px; margin: 10px 0; border-radius: 8px; border-left: 4px solid ${color};">
                            <strong>${result.label}</strong> - ${status}<br>
                            <small>Start: (${result.start.x}, ${result.start.y})</small><br>
                            <small>Iterations: ${result.iterations}</small><br>
                            ${result.converged ? `<small>Final: (${result.finalPoint.x.toFixed(6)}, ${result.finalPoint.y.toFixed(6)})</small>` : ''}
                        </div>
                    `;
                });
                
                resultsDiv.innerHTML = html;
            }
            
            clearComparison() {
                const canvas = this.canvas;
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const chartCanvas = this.chartCanvas;
                const chartCtx = chartCanvas.getContext('2d');
                chartCtx.clearRect(0, 0, chartCanvas.width, chartCanvas.height);
                
                document.getElementById('comparisonResults').innerHTML = '';
                this.results = [];
            }
        }

        // ===== CUSTOM SYSTEM =====
        function setupCustomSystem() {
            document.getElementById('testCustomBtn').onclick = testCustomFunctions;
            document.getElementById('applyCustomBtn').onclick = applyCustomSystem;
        }
        
        function testCustomFunctions() {
            const resultDiv = document.getElementById('customTestResult');
            
            try {
                const f1 = new Function('x', 'y', 'return ' + document.getElementById('customF1').value);
                const f2 = new Function('x', 'y', 'return ' + document.getElementById('customF2').value);
                
                // Test at a point
                const testX = 1, testY = 1;
                const v1 = f1(testX, testY);
                const v2 = f2(testX, testY);
                
                if (typeof v1 !== 'number' || typeof v2 !== 'number' || isNaN(v1) || isNaN(v2)) {
                    throw new Error('Functions must return numbers');
                }
                
                resultDiv.innerHTML = `
                    <div class="status-message success">
                        ✓ Functions are valid!<br>
                        <small>Test at (${testX}, ${testY}): f₁ = ${v1.toFixed(4)}, f₂ = ${v2.toFixed(4)}</small>
                    </div>
                `;
            } catch (error) {
                resultDiv.innerHTML = `
                    <div class="status-message error">
                        ✗ Error: ${error.message}<br>
                        <small>Check your function syntax</small>
                    </div>
                `;
            }
        }
        
        function applyCustomSystem() {
            const resultDiv = document.getElementById('customTestResult');
            
            try {
                const f1Str = document.getElementById('customF1').value;
                const f2Str = document.getElementById('customF2').value;
                
                const f1 = new Function('x', 'y', 'return ' + f1Str);
                const f2 = new Function('x', 'y', 'return ' + f2Str);
                
                // Test functions
                const v1 = f1(1, 1);
                const v2 = f2(1, 1);
                
                if (typeof v1 !== 'number' || typeof v2 !== 'number' || isNaN(v1) || isNaN(v2)) {
                    throw new Error('Functions must return numbers');
                }
                
                // Update custom system
                systems.custom.f = (x, y) => [f1(x, y), f2(x, y)];
                systems.custom.equations = [f1Str, f2Str];
                
                // Check if Jacobian is provided
                const df1dx = document.getElementById('customDf1dx').value.trim();
                const df1dy = document.getElementById('customDf1dy').value.trim();
                const df2dx = document.getElementById('customDf2dx').value.trim();
                const df2dy = document.getElementById('customDf2dy').value.trim();
                
                if (df1dx && df1dy && df2dx && df2dy) {
                    const jac11 = new Function('x', 'y', 'return ' + df1dx);
                    const jac12 = new Function('x', 'y', 'return ' + df1dy);
                    const jac21 = new Function('x', 'y', 'return ' + df2dx);
                    const jac22 = new Function('x', 'y', 'return ' + df2dy);
                    
                    // Test Jacobian
                    jac11(1, 1); jac12(1, 1); jac21(1, 1); jac22(1, 1);
                    
                    systems.custom.jacobian = (x, y) => [
                        [jac11(x, y), jac12(x, y)],
                        [jac21(x, y), jac22(x, y)]
                    ];
                    
                    resultDiv.innerHTML = `
                        <div class="status-message success">
                            ✓ Custom system applied with analytical Jacobian!<br>
                            <small>Switching to simulation tab...</small>
                        </div>
                    `;
                } else {
                    // Will use numerical Jacobian
                    systems.custom.jacobian = null;
                    
                    resultDiv.innerHTML = `
                        <div class="status-message success">
                            ✓ Custom system applied! Will use numerical Jacobian.<br>
                            <small>Switching to simulation tab...</small>
                        </div>
                    `;
                }
                
                // Update custom system button text
                document.getElementById('customEq1').textContent = 'f₁: ' + f1Str;
                document.getElementById('customEq2').textContent = 'f₂: ' + f2Str;
                
                // Show the custom system button
                document.getElementById('customSystemBtn').style.display = 'block';
                
                // Switch to simulation tab and select custom system
                setTimeout(() => {
                    switchTab('simulation');
                    
                    // Deselect all system buttons
                    document.querySelectorAll('.system-btn').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    
                    // Select custom system button
                    const customBtn = document.getElementById('customSystemBtn');
                    customBtn.classList.add('active');
                    
                    // Update solver if it exists
                    if (solver) {
                        solver.systemType = 'custom';
                        solver.reset();
                        solver.updateStatus('Custom system loaded! ' + 
                            (systems.custom.jacobian ? 'Using analytical Jacobian.' : 'Using numerical Jacobian.'), 
                            'success');
                    }
                }, 1000);
                
            } catch (error) {
                resultDiv.innerHTML = `
                    <div class="status-message error">
                        ✗ Error: ${error.message}<br>
                        <small>Check your function syntax</small>
                    </div>
                `;
            }
        }

        // ===== INITIALIZATION =====
        let solver = null;
        let comparisonMode = null;

        function switchTab(tabName) {
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            document.querySelectorAll('.nav-tab').forEach(btn => {
                btn.classList.remove('active');
            });
            
            document.getElementById(tabName).classList.add('active');
            document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
            
            if (tabName === 'simulation' && !solver) {
                setTimeout(() => {
                    solver = new NewtonSolver();
                }, 100);
            } else if (tabName === 'comparison' && !comparisonMode) {
                setTimeout(() => {
                    comparisonMode = new ComparisonMode();
                }, 100);
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            // Setup tab switching
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.addEventListener('click', function() {
                    const tabName = this.getAttribute('data-tab');
                    switchTab(tabName);
                });
            });
            
            // Setup custom system
            setupCustomSystem();
            
            // Initialize solver
            setTimeout(() => {
                solver = new NewtonSolver();
            }, 100);
        });
    </script>
</body>
</html>