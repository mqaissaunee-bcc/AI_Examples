<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Buffer Overflow Interactive Explainer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 2.2em;
        }

        .subtitle {
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .section {
            margin-bottom: 40px;
        }

        h2 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.6em;
        }

        .demo-box {
            background: #f8f9fa;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }

        .memory-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 20px 0;
        }

        .memory-block {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .memory-label {
            min-width: 150px;
            font-weight: bold;
            color: #555;
            font-size: 0.9em;
        }

        .memory-cells {
            display: flex;
            gap: 2px;
            flex-wrap: wrap;
        }

        .memory-cell {
            width: 40px;
            height: 40px;
            border: 2px solid #ddd;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            background: white;
            transition: all 0.3s;
            border-radius: 4px;
        }

        .memory-cell.filled {
            background: #4CAF50;
            color: white;
            border-color: #45a049;
        }

        .memory-cell.overflow {
            background: #f44336;
            color: white;
            border-color: #da190b;
            animation: pulse 0.5s;
        }

        .memory-cell.corrupted {
            background: #ff9800;
            color: white;
            border-color: #e68900;
            animation: shake 0.5s;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        .input-group {
            margin: 20px 0;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #555;
        }

        input[type="text"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 1em;
            font-family: 'Courier New', monospace;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
        }

        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 6px;
            font-size: 1em;
            cursor: pointer;
            transition: background 0.3s;
            margin-right: 10px;
        }

        button:hover {
            background: #5568d3;
        }

        button:active {
            transform: translateY(1px);
        }

        .alert {
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
            font-weight: bold;
        }

        .alert-info {
            background: #e3f2fd;
            color: #1976d2;
            border-left: 4px solid #1976d2;
        }

        .alert-warning {
            background: #fff3e0;
            color: #f57c00;
            border-left: 4px solid #f57c00;
        }

        .alert-danger {
            background: #ffebee;
            color: #c62828;
            border-left: 4px solid #c62828;
        }

        .code-block {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
            margin: 15px 0;
            font-size: 0.9em;
            line-height: 1.6;
        }

        .legend {
            display: flex;
            gap: 20px;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9em;
        }

        .legend-box {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            border: 2px solid #ddd;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .stat-box {
            background: #f0f4ff;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            color: #666;
            font-size: 0.9em;
            margin-top: 5px;
        }

        .explanation {
            background: #f9f9f9;
            padding: 15px;
            border-left: 4px solid #667eea;
            border-radius: 4px;
            margin: 15px 0;
            line-height: 1.6;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
        }

        .tab {
            padding: 10px 20px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1em;
            color: #666;
            position: relative;
            transition: color 0.3s;
        }

        .tab.active {
            color: #667eea;
        }

        .tab.active::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            right: 0;
            height: 2px;
            background: #667eea;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîê Buffer Overflow Interactive Explainer</h1>
        <p class="subtitle">Learn how buffer overflows work and why they're dangerous</p>

        <div class="section">
            <h2>What is a Buffer?</h2>
            <div class="explanation">
                A <strong>buffer</strong> is a temporary storage area in memory used to hold data. Think of it as a container with a fixed size. When a program allocates a buffer, it reserves a specific amount of memory to store data like strings, arrays, or other information.
            </div>
        </div>

        <div class="section">
            <h2>Interactive Demo</h2>
            
            <div class="tabs">
                <button class="tab active" onclick="switchTab('basic')">Basic Overflow</button>
                <button class="tab" onclick="switchTab('attack')">Attack Simulation</button>
                <button class="tab" onclick="switchTab('protection')">Protection Methods</button>
            </div>

            <div id="basic" class="tab-content active">
                <div class="demo-box">
                    <div class="input-group">
                        <label>Enter text (Buffer size: 8 characters)</label>
                        <input type="text" id="userInput" maxlength="20" placeholder="Type here...">
                    </div>

                    <div class="stats">
                        <div class="stat-box">
                            <div class="stat-value" id="charCount">0</div>
                            <div class="stat-label">Characters Entered</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value" id="bufferUsage">0%</div>
                            <div class="stat-label">Buffer Usage</div>
                        </div>
                    </div>

                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-box" style="background: white;"></div>
                            <span>Empty</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-box" style="background: #4CAF50;"></div>
                            <span>Valid Data</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-box" style="background: #f44336;"></div>
                            <span>Overflow</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-box" style="background: #ff9800;"></div>
                            <span>Corrupted</span>
                        </div>
                    </div>

                    <div class="memory-container" id="memoryDisplay"></div>

                    <div id="statusMessage"></div>
                </div>
            </div>

            <div id="attack" class="tab-content">
                <div class="demo-box">
                    <div class="explanation">
                        In this simulation, we have a vulnerable login system. An attacker can exploit a buffer overflow to overwrite the <code>isAdmin</code> flag stored in adjacent memory.
                    </div>

                    <div class="code-block">// Vulnerable C code example
char username[8];
int isAdmin = 0;

void login(char* input) {
    strcpy(username, input); // No bounds checking!
    
    if (isAdmin == 1) {
        printf("Access granted!");
    }
}</div>

                    <div class="input-group">
                        <label>Username (Buffer size: 8)</label>
                        <input type="text" id="attackInput" maxlength="20" placeholder="Try entering more than 8 characters...">
                    </div>

                    <div class="memory-container" id="attackMemoryDisplay"></div>

                    <div id="attackStatus"></div>

                    <button onclick="demonstrateAttack()">Demonstrate Exploit</button>
                    <button onclick="resetAttack()">Reset</button>
                </div>
            </div>

            <div id="protection" class="tab-content">
                <div class="demo-box">
                    <h3>How to Prevent Buffer Overflows</h3>
                    
                    <div class="explanation">
                        <strong>1. Bounds Checking:</strong> Always validate input length before copying
                    </div>
                    <div class="code-block">// Safe version
if (strlen(input) < sizeof(username)) {
    strcpy(username, input);
} else {
    // Handle error
}</div>

                    <div class="explanation">
                        <strong>2. Safe Functions:</strong> Use bounds-checking alternatives
                    </div>
                    <div class="code-block">// Use strncpy instead of strcpy
strncpy(username, input, sizeof(username) - 1);
username[sizeof(username) - 1] = '\0';

// Or use safer C functions
strcpy_s(username, sizeof(username), input);</div>

                    <div class="explanation">
                        <strong>3. Memory Protection:</strong> Modern systems use:
                        <ul style="margin-top: 10px; margin-left: 20px; line-height: 2;">
                            <li><strong>ASLR</strong> (Address Space Layout Randomization): Randomizes memory addresses</li>
                            <li><strong>DEP</strong> (Data Execution Prevention): Prevents code execution from data segments</li>
                            <li><strong>Stack Canaries</strong>: Detect stack corruption before function returns</li>
                            <li><strong>Compiler Protections</strong>: Modern compilers add overflow detection</li>
                        </ul>
                    </div>

                    <div class="explanation">
                        <strong>4. Use Memory-Safe Languages:</strong>
                        <ul style="margin-top: 10px; margin-left: 20px; line-height: 2;">
                            <li><strong>Rust:</strong> Prevents buffer overflows at compile time</li>
                            <li><strong>Go, Java, Python:</strong> Automatic bounds checking</li>
                            <li><strong>Modern C++:</strong> Use std::string and containers instead of raw arrays</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>Why Are Buffer Overflows Dangerous?</h2>
            <div class="alert alert-danger">
                <strong>‚ö†Ô∏è Security Impact:</strong> Buffer overflows can allow attackers to:
                <ul style="margin-top: 10px; margin-left: 20px;">
                    <li>Execute arbitrary code on the target system</li>
                    <li>Crash programs and cause denial of service</li>
                    <li>Bypass authentication and access controls</li>
                    <li>Steal sensitive data from memory</li>
                    <li>Gain complete control of a system</li>
                </ul>
            </div>
        </div>

        <div class="section">
            <h2>Real-World Examples</h2>
            
            <div class="explanation">
                <strong>Morris Worm (1988):</strong> One of the first major internet worms that exploited a buffer overflow in Unix's <code>fingerd</code> service.
                <br><br>
                <strong>How it worked:</strong> The finger daemon had a function that used <code>gets()</code> to read input into a 512-byte buffer without checking the input length. The Morris Worm sent a carefully crafted string longer than 512 bytes, overwriting the return address on the stack. When the function returned, instead of going back to the caller, execution jumped to the attacker's code (called "shellcode") that was included in the overflow data. This shellcode then established a connection back to the worm, allowing it to replicate to the compromised system.
                <br><br>
                <strong>Impact:</strong> Affected approximately 6,000 systems (about 10% of the internet at the time), causing an estimated $10-100 million in damage. This incident led to the creation of the first Computer Emergency Response Team (CERT).
            </div>

            <div class="explanation">
                <strong>Code Red (2001):</strong> Exploited a buffer overflow in Microsoft's Internet Information Services (IIS) web server.
                <br><br>
                <strong>How it worked:</strong> IIS had a vulnerability in its indexing service that processed .ida and .idq files. The worm sent an HTTP GET request with an extremely long URL containing ".ida" - specifically, a URL with about 240 bytes of the character 'N' followed by shellcode. This overflowed a stack buffer that was only allocated for a much shorter filename. The overflow overwrote the return address, redirecting execution to the shellcode embedded in the malicious URL. The shellcode then spawned a command shell and allowed the worm to execute arbitrary commands, including replicating itself to other servers.
                <br><br>
                <strong>Impact:</strong> Infected over 350,000 systems in just 14 hours. On July 19, 2001, it launched a DDoS attack against the White House website. Caused an estimated $2.6 billion in damage through system downtime and cleanup costs.
            </div>

            <div class="explanation">
                <strong>Heartbleed (2014):</strong> While technically a "buffer over-read" rather than an overflow, this bug in OpenSSL demonstrates similar boundary-checking failures.
                <br><br>
                <strong>How it worked:</strong> OpenSSL's implementation of the TLS heartbeat feature had a critical flaw. When a client sent a heartbeat request, it would specify: "I'm sending you X bytes of data, please echo it back." However, the server didn't verify that the client actually sent X bytes. An attacker could claim to send 64KB of data but only send 1 byte. The server would then read and return 64KB from memory starting at that 1 byte - effectively reading 64KB beyond the intended buffer. This leaked random data from the server's memory, which could include private keys, passwords, session tokens, and other sensitive data from other users.
                <br><br>
                <strong>Impact:</strong> Affected approximately 17% of all SSL-secured websites (about 500,000 sites). Exposed private encryption keys, user credentials, and sensitive data. The vulnerability existed in OpenSSL for over two years before discovery, meaning data could have been silently stolen during that entire period.
            </div>

            <div class="alert alert-info">
                <strong>üí° Common Pattern:</strong> Notice how all three exploits share a critical failure - <strong>trusting user input without validation</strong>. Whether it's the length of a username, a URL, or a heartbeat payload size, the vulnerable code assumed the input was valid and safe. This is why modern secure coding practices emphasize "never trust user input" and always validate data boundaries.
            </div>
        </div>
    </div>

    <script>
        const BUFFER_SIZE = 8;

        function initMemoryDisplay() {
            const container = document.getElementById('memoryDisplay');
            container.innerHTML = `
                <div class="memory-block">
                    <div class="memory-label">Buffer [0-7]:</div>
                    <div class="memory-cells" id="bufferCells"></div>
                </div>
                <div class="memory-block">
                    <div class="memory-label">Return Address:</div>
                    <div class="memory-cells" id="returnCells"></div>
                </div>
                <div class="memory-block">
                    <div class="memory-label">Other Data:</div>
                    <div class="memory-cells" id="otherCells"></div>
                </div>
            `;

            for (let i = 0; i < BUFFER_SIZE; i++) {
                document.getElementById('bufferCells').innerHTML += `<div class="memory-cell" id="cell${i}"></div>`;
            }
            for (let i = 0; i < 4; i++) {
                document.getElementById('returnCells').innerHTML += `<div class="memory-cell" id="return${i}">??</div>`;
            }
            for (let i = 0; i < 4; i++) {
                document.getElementById('otherCells').innerHTML += `<div class="memory-cell" id="other${i}">??</div>`;
            }
        }

        function initAttackMemoryDisplay() {
            const container = document.getElementById('attackMemoryDisplay');
            container.innerHTML = `
                <div class="memory-block">
                    <div class="memory-label">username[8]:</div>
                    <div class="memory-cells" id="attackBufferCells"></div>
                </div>
                <div class="memory-block">
                    <div class="memory-label">isAdmin flag:</div>
                    <div class="memory-cells" id="adminFlag"></div>
                </div>
            `;

            for (let i = 0; i < 8; i++) {
                document.getElementById('attackBufferCells').innerHTML += `<div class="memory-cell" id="acell${i}"></div>`;
            }
            document.getElementById('adminFlag').innerHTML = `<div class="memory-cell" id="adminCell">0</div>`;
        }

        function updateMemory(input) {
            const charCount = input.length;
            const percentage = Math.min((charCount / BUFFER_SIZE) * 100, 100);
            
            document.getElementById('charCount').textContent = charCount;
            document.getElementById('bufferUsage').textContent = Math.round(percentage) + '%';

            // Clear all cells first
            for (let i = 0; i < BUFFER_SIZE; i++) {
                const cell = document.getElementById(`cell${i}`);
                cell.textContent = '';
                cell.className = 'memory-cell';
            }

            // Reset return address and other data
            for (let i = 0; i < 4; i++) {
                const returnCell = document.getElementById(`return${i}`);
                returnCell.className = 'memory-cell';
                returnCell.textContent = '??';
                
                const otherCell = document.getElementById(`other${i}`);
                otherCell.className = 'memory-cell';
                otherCell.textContent = '??';
            }

            // Fill buffer
            for (let i = 0; i < input.length; i++) {
                if (i < BUFFER_SIZE) {
                    const cell = document.getElementById(`cell${i}`);
                    cell.textContent = input[i];
                    cell.className = 'memory-cell filled';
                } else {
                    // Overflow into return address
                    const overflowIndex = i - BUFFER_SIZE;
                    if (overflowIndex < 4) {
                        const returnCell = document.getElementById(`return${overflowIndex}`);
                        returnCell.textContent = input[i];
                        returnCell.className = 'memory-cell overflow';
                    } else if (overflowIndex < 8) {
                        const otherCell = document.getElementById(`other${overflowIndex - 4}`);
                        otherCell.textContent = input[i];
                        otherCell.className = 'memory-cell corrupted';
                    }
                }
            }

            // Update status message
            const statusDiv = document.getElementById('statusMessage');
            if (charCount === 0) {
                statusDiv.innerHTML = '';
            } else if (charCount <= BUFFER_SIZE) {
                statusDiv.innerHTML = '<div class="alert alert-info">‚úì Safe: Data fits within buffer</div>';
            } else if (charCount <= BUFFER_SIZE + 4) {
                statusDiv.innerHTML = '<div class="alert alert-warning">‚ö†Ô∏è Warning: Buffer overflow! Return address is being overwritten. This could allow an attacker to redirect program execution!</div>';
            } else {
                statusDiv.innerHTML = '<div class="alert alert-danger">üö® Critical: Severe overflow! Multiple memory regions corrupted. System crash or exploitation likely!</div>';
            }
        }

        function updateAttackMemory(input) {
            // Clear attack cells
            for (let i = 0; i < 8; i++) {
                const cell = document.getElementById(`acell${i}`);
                cell.textContent = '';
                cell.className = 'memory-cell';
            }

            const adminCell = document.getElementById('adminCell');
            adminCell.textContent = '0';
            adminCell.className = 'memory-cell';

            // Fill username buffer
            for (let i = 0; i < input.length; i++) {
                if (i < 8) {
                    const cell = document.getElementById(`acell${i}`);
                    cell.textContent = input[i];
                    cell.className = 'memory-cell filled';
                } else {
                    // Overflow into isAdmin
                    adminCell.textContent = '1';
                    adminCell.className = 'memory-cell overflow';
                }
            }

            // Update attack status
            const statusDiv = document.getElementById('attackStatus');
            if (input.length > 8) {
                statusDiv.innerHTML = `
                    <div class="alert alert-danger">
                        üö® <strong>EXPLOIT SUCCESSFUL!</strong><br>
                        The isAdmin flag has been overwritten from 0 to 1.<br>
                        Access granted without valid credentials!
                    </div>
                `;
            } else if (input.length > 0) {
                statusDiv.innerHTML = '<div class="alert alert-info">‚úì Normal operation - no overflow</div>';
            } else {
                statusDiv.innerHTML = '';
            }
        }

        function demonstrateAttack() {
            const input = document.getElementById('attackInput');
            input.value = 'AAAAAAAA1';
            updateAttackMemory(input.value);
        }

        function resetAttack() {
            document.getElementById('attackInput').value = '';
            updateAttackMemory('');
        }

        function switchTab(tabName) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });

            // Remove active from all tabs
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });

            // Show selected tab content
            document.getElementById(tabName).classList.add('active');
            event.target.classList.add('active');
        }

        // Event listeners
        document.getElementById('userInput').addEventListener('input', (e) => {
            updateMemory(e.target.value);
        });

        document.getElementById('attackInput').addEventListener('input', (e) => {
            updateAttackMemory(e.target.value);
        });

        // Initialize displays
        initMemoryDisplay();
        initAttackMemoryDisplay();
        updateMemory('');
    </script>
</body>
</html>
